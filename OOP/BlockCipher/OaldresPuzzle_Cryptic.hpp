/*
 * Copyright (C) 2023-2050 Twilight-Dream
 *
 * 本文件是 Algorithm_OaldresPuzzleCryptic 的一部分。
 *
 * Algorithm_OaldresPuzzleCryptic 是自由软件：你可以再分发之和/或依照由自由软件基金会发布的 GNU 通用公共许可证修改之，无论是版本 3 许可证，还是（按你的决定）任何以后版都可以。
 *
 * 发布 Algorithm_OaldresPuzzleCryptic 是希望它能有用，但是并无保障;甚至连可销售和符合某个特定的目的都不保证。请参看 GNU 通用公共许可证，了解详情。
 * 你应该随程序获得一份 GNU 通用公共许可证的复本。如果没有，请看 <https://www.gnu.org/licenses/>。
 */
 
 /*
 * Copyright (C) 2023-2050 Twilight-Dream
 *
 * This file is part of Algorithm_OaldresPuzzleCryptic.
 *
 * Algorithm_OaldresPuzzleCryptic is free software: you may redistribute it and/or modify it under the GNU General Public License as published by the Free Software Foundation, either under the Version 3 license, or (at your discretion) any later version.
 *
 * TDOM-EncryptOrDecryptFile-Reborn is released in the hope that it will be useful, but there are no guarantees; not even that it will be marketable and fit a particular purpose. Please see the GNU General Public License for details.
 * You should get a copy of the GNU General Public License with your program. If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef ALGORITHM_OALDRESPUZZLECRYPTIC_OALDRESPUZZLE_CRYPTIC_HPP
#define ALGORITHM_OALDRESPUZZLECRYPTIC_OALDRESPUZZLE_CRYPTIC_HPP

#include "Module_SecureSubkeyGeneratation.hpp"
#include "Module_SecureRoundSubkeyGeneratation.hpp"

namespace TwilightDreamOfMagical::CustomSecurity
{
	//SymmetricEncryptionDecryption
	namespace SED::BlockCipher
	{
		class OaldresPuzzle_Cryptic
		{

			friend class OPC_MainAlgorithm_Worker;

		public:

			explicit OaldresPuzzle_Cryptic(ImplementationDetails::CommonStateData& CommonStateDataObject)
				:
				  StateDataPointer(std::addressof(CommonStateDataObject)),
				  SecureSubkeyGeneratationModuleObject(CommonStateDataObject),
				  SecureRoundSubkeyGeneratationModuleObject(CommonStateDataObject)
			{

			}

			~OaldresPuzzle_Cryptic() = default;

			void LaiMasseyFrameworkTest()
			{
				auto TestDataArray2 = this->SecureRoundSubkeyGeneratationModuleObject.ForwardTransform(123456789U, 987654321U);
				TestDataArray2 = this->SecureRoundSubkeyGeneratationModuleObject.BackwardTransform(TestDataArray2[0], TestDataArray2[1]);

				if(TestDataArray2[0] != 123456789U || TestDataArray2[1] != 987654321U)
				{
					std::cout << "Self sanity check error: Data does not match (H-functions), LaiMasseyFramework function is incorrect!" << std::endl;
				}

				std::array<std::uint64_t, 2> TestDataArray { 112233445566778899ULL, 998877665544332211ULL };
				std::array<std::uint64_t, 2> TestKeyArray { 147852369369852147ULL, 987456321123654789ULL };

				std::mt19937_64 PRNG(1);
				std::vector<std::uint64_t> MasterKeys(32, 0);
				for ( size_t i = 0; i < MasterKeys.size(); i++ )
				{
					MasterKeys[i] = PRNG();
				}
				this->SecureSubkeyGeneratationModuleObject.GenerationSubkeys(MasterKeys);
				this->SecureRoundSubkeyGeneratationModuleObject.GenerationRoundSubkeys();

				TestDataArray[0] = this->LaiMasseyFramework(TestDataArray[0], TestKeyArray[0], CryptionMode2MCAC4_FDW::MCA_ENCRYPTER);
				TestDataArray[1] = this->LaiMasseyFramework(TestDataArray[1], TestKeyArray[1], CryptionMode2MCAC4_FDW::MCA_ENCRYPTER);

				TestDataArray[1] = this->LaiMasseyFramework(TestDataArray[1], TestKeyArray[1], CryptionMode2MCAC4_FDW::MCA_DECRYPTER);
				TestDataArray[0] = this->LaiMasseyFramework(TestDataArray[0], TestKeyArray[0], CryptionMode2MCAC4_FDW::MCA_DECRYPTER);

				if(TestDataArray[0] != 112233445566778899ULL || TestDataArray[1] != 998877665544332211ULL)
				{
					std::cout << "Self sanity check error: Data does not match (F-functions), LaiMasseyFramework function is incorrect!" << std::endl;
				}

				std::cout << "Self sanity check passed !" << std::endl;
			}

		private:

			ImplementationDetails::CommonStateData* StateDataPointer = nullptr;
			ImplementationDetails::Module_SecureSubkeyGeneratation SecureSubkeyGeneratationModuleObject;
			ImplementationDetails::Module_SecureRoundSubkeyGeneratation SecureRoundSubkeyGeneratationModuleObject;

			//China Pediy BBS: https://bbs.pediy.com/thread-253916.htm
			//AES Forward SubstitutionBox Modified
			//Primitive polynomial degree is 8
			//x^8 + x^5 + x^4 + x^3 + x^2 + x + 1
			/*
				This byte-substitution box: Strict avalanche criterion is satisfied !
				Transparency Order Is: 7.85564
				Nonlinearity Is: 112
				Propagation Characteristics Is: 8
				Delta Uniformity Is: 4
				Robustness Is: 0.984375
				Signal To Noise Ratio/Differential Power Analysis Is: 9.84433
				Absolute Value Indicatorer Is: 32
				Sum Of Square Value Indicator Is: 67584
				Algebraic Degree Is: 7
				Algebraic Immunity Degree Is: 4
			*/
			static constexpr std::array<std::uint8_t, 256> ForwardSubstitutionBox0
			{
				0x7F, 0x84, 0x01, 0x2B, 0xC3, 0x4E, 0x55, 0x58, 0x21, 0x62, 0x64, 0xF1, 0xE9, 0x81, 0x6F, 0x6D,
				0x50, 0x71, 0x72, 0x61, 0xF2, 0xA9, 0xBB, 0xD7, 0xB7, 0xF8, 0x00, 0x74, 0xF4, 0x05, 0x76, 0x6E,
				0xE8, 0x8F, 0x78, 0x34, 0xF9, 0x28, 0xF3, 0x54, 0x3A, 0x6C, 0x14, 0x02, 0x1D, 0x7B, 0xA8, 0x5E,
				0x98, 0x25, 0x3F, 0x87, 0xC0, 0x8A, 0x79, 0xE2, 0xBA, 0xE5, 0xC1, 0x24, 0xFB, 0x13, 0xF7, 0xCF,
				0xB4, 0x12, 0x07, 0x95, 0xFC, 0x8D, 0xDA, 0x5B, 0x3C, 0x53, 0xD4, 0x09, 0x39, 0x4B, 0xEA, 0x27,
				0xDD, 0xB9, 0x75, 0xB6, 0x49, 0xD5, 0x42, 0x3E, 0xCD, 0xF6, 0x7D, 0x5F, 0x17, 0xA1, 0xEF, 0xD3,
				0x0F, 0x0B, 0x52, 0x2F, 0xDC, 0x46, 0x80, 0x30, 0xA0, 0x99, 0x06, 0x56, 0xFF, 0xE0, 0xB1, 0xB0,
				0x1E, 0x60, 0x32, 0x8E, 0xA3, 0x67, 0x51, 0x7E, 0xBE, 0x15, 0xCA, 0x8C, 0x3B, 0xAB, 0xA4, 0x16,
				0x19, 0xA7, 0xC9, 0x4D, 0x43, 0x94, 0x89, 0xCC, 0x3D, 0x70, 0x85, 0x59, 0x2E, 0xD1, 0xEE, 0x9E,
				0x5D, 0x8B, 0x69, 0x77, 0x29, 0xD2, 0x44, 0x63, 0x5C, 0x82, 0x65, 0x45, 0x36, 0x1A, 0xD0, 0x88,
				0xAD, 0xD6, 0x9F, 0xAC, 0x7A, 0x4F, 0x9B, 0x41, 0xE7, 0x47, 0x2A, 0xB2, 0xE1, 0x0D, 0xDF, 0x97,
				0x26, 0xC5, 0x38, 0x6B, 0xFD, 0x2D, 0xEC, 0xF5, 0xC8, 0x10, 0x93, 0x20, 0x37, 0x9A, 0xAA, 0xA2,
				0xC4, 0xB3, 0xC6, 0xA6, 0x6A, 0xDB, 0x57, 0x0A, 0xAE, 0x9C, 0xE3, 0x08, 0x03, 0x1F, 0xD8, 0x2C,
				0x90, 0xB5, 0x0C, 0x83, 0x40, 0x23, 0x68, 0x91, 0xBC, 0x22, 0x33, 0x66, 0x18, 0xAF, 0x1B, 0xCE,
				0x4C, 0xE4, 0xF0, 0xFE, 0x5A, 0x0E, 0x04, 0x35, 0x11, 0xBD, 0x73, 0xFA, 0xEB, 0x9D, 0x7C, 0x48,
				0x1C, 0xD9, 0x4A, 0xC2, 0xA5, 0xC7, 0x86, 0xED, 0xDE, 0xBF, 0x96, 0xB8, 0x92, 0x31, 0xCB, 0xE6
			};

			//China Pediy BBS: https://bbs.pediy.com/thread-253916.htm
			//AES Backward SubstitutionBox Modified
			//Primitive polynomial degree is 8
			//x^8 + x^5 + x^4 + x^3 + x^2 + x + 1
			/*
				This byte-substitution box: Strict avalanche criterion is satisfied !
				Transparency Order Is: 7.85711
				Nonlinearity Is: 112
				Propagation Characteristics Is: 8
				Delta Uniformity Is: 4
				Robustness Is: 0.984375
				Signal To Noise Ratio/Differential Power Analysis Is: 9.71063
				Absolute Value Indicatorer Is: 32
				Sum Of Square Value Indicator Is: 67584
				Algebraic Degree Is: 8
				Algebraic Immunity Degree Is: 4
			*/
			static constexpr std::array<std::uint8_t, 256> BackwardSubstitutionBox0
			{
				0x1A, 0x02, 0x2B, 0xCC, 0xE6, 0x1D, 0x6A, 0x42, 0xCB, 0x4B, 0xC7, 0x61, 0xD2, 0xAD, 0xE5, 0x60,
				0xB9, 0xE8, 0x41, 0x3D, 0x2A, 0x79, 0x7F, 0x5C, 0xDC, 0x80, 0x9D, 0xDE, 0xF0, 0x2C, 0x70, 0xCD,
				0xBB, 0x08, 0xD9, 0xD5, 0x3B, 0x31, 0xB0, 0x4F, 0x25, 0x94, 0xAA, 0x03, 0xCF, 0xB5, 0x8C, 0x63,
				0x67, 0xFD, 0x72, 0xDA, 0x23, 0xE7, 0x9C, 0xBC, 0xB2, 0x4C, 0x28, 0x7C, 0x48, 0x88, 0x57, 0x32,
				0xD4, 0xA7, 0x56, 0x84, 0x96, 0x9B, 0x65, 0xA9, 0xEF, 0x54, 0xF2, 0x4D, 0xE0, 0x83, 0x05, 0xA5,
				0x10, 0x76, 0x62, 0x49, 0x27, 0x06, 0x6B, 0xC6, 0x07, 0x8B, 0xE4, 0x47, 0x98, 0x90, 0x2F, 0x5B,
				0x71, 0x13, 0x09, 0x97, 0x0A, 0x9A, 0xDB, 0x75, 0xD6, 0x92, 0xC4, 0xB3, 0x29, 0x0F, 0x1F, 0x0E,
				0x89, 0x11, 0x12, 0xEA, 0x1B, 0x52, 0x1E, 0x93, 0x22, 0x36, 0xA4, 0x2D, 0xEE, 0x5A, 0x77, 0x00,
				0x66, 0x0D, 0x99, 0xD3, 0x01, 0x8A, 0xF6, 0x33, 0x9F, 0x86, 0x35, 0x91, 0x7B, 0x45, 0x73, 0x21,
				0xD0, 0xD7, 0xFC, 0xBA, 0x85, 0x43, 0xFA, 0xAF, 0x30, 0x69, 0xBD, 0xA6, 0xC9, 0xED, 0x8F, 0xA2,
				0x68, 0x5D, 0xBF, 0x74, 0x7E, 0xF4, 0xC3, 0x81, 0x2E, 0x15, 0xBE, 0x7D, 0xA3, 0xA0, 0xC8, 0xDD,
				0x6F, 0x6E, 0xAB, 0xC1, 0x40, 0xD1, 0x53, 0x18, 0xFB, 0x51, 0x38, 0x16, 0xD8, 0xE9, 0x78, 0xF9,
				0x34, 0x3A, 0xF3, 0x04, 0xC0, 0xB1, 0xC2, 0xF5, 0xB8, 0x82, 0x7A, 0xFE, 0x87, 0x58, 0xDF, 0x3F,
				0x9E, 0x8D, 0x95, 0x5F, 0x4A, 0x55, 0xA1, 0x17, 0xCE, 0xF1, 0x46, 0xC5, 0x64, 0x50, 0xF8, 0xAE,
				0x6D, 0xAC, 0x37, 0xCA, 0xE1, 0x39, 0xFF, 0xA8, 0x20, 0x0C, 0x4E, 0xEC, 0xB6, 0xF7, 0x8E, 0x5E,
				0xE2, 0x0B, 0x14, 0x26, 0x1C, 0xB7, 0x59, 0x3E, 0x19, 0x24, 0xEB, 0x3C, 0x44, 0xB4, 0xE3, 0x6C
			};

			//China ZUC Cipher Forward SubstitutionBox
			/*
				This byte-substitution box: Strict avalanche criterion is satisfied !
				Transparency Order Is: 7.86103
				Nonlinearity Is: 112
				Propagation Characteristics Is: 8
				Delta Uniformity Is: 4
				Robustness Is: 0.984375
				Signal To Noise Ratio/Differential Power Analysis Is: 9.28457
				Absolute Value Indicatorer Is: 32
				Sum Of Square Value Indicator Is: 67584
				Algebraic Degree Is: 8
				Algebraic Immunity Degree Is: 4
			*/
			static constexpr std::array<std::uint8_t, 256> ForwardSubstitutionBox1
			{
				0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77,
				0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42,
				0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1,
				0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48,
				0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87,
				0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB,
				0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09,
				0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9,
				0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9,
				0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89,
				0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4,
				0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE,
				0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21,
				0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34,
				0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28,
				0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2
			};

			//China ZUC Cipher Backward SubstitutionBox
			/*
				This byte-substitution box: Strict avalanche criterion is satisfied !
				Transparency Order Is: 7.86029
				Nonlinearity Is: 112
				Propagation Characteristics Is: 8
				Delta Uniformity Is: 4
				Robustness Is: 0.984375
				Signal To Noise Ratio/Differential Power Analysis Is: 8.93855
				Absolute Value Indicatorer Is: 32
				Sum Of Square Value Indicator Is: 67584
				Algebraic Degree Is: 7
				Algebraic Immunity Degree Is: 4
			*/
			static constexpr std::array<std::uint8_t, 256> BackwardSubstitutionBox1
			{
				0x17, 0xA0, 0xBB, 0xFD, 0xEE, 0x37, 0x43, 0xDA, 0x6E, 0x6F, 0xDB, 0x3C, 0x13, 0x85, 0xDE, 0xB5,
				0x28, 0x42, 0xFC, 0x16, 0x65, 0xAA, 0x1A, 0x66, 0xC6, 0x76, 0x15, 0xC8, 0x9B, 0x8B, 0xD3, 0xEB,
				0x41, 0xCF, 0x38, 0x68, 0xA4, 0xF9, 0x21, 0x49, 0xEF, 0x0C, 0x33, 0x60, 0xC9, 0x88, 0x83, 0xF4,
				0x6B, 0xD5, 0xEC, 0xD9, 0xDF, 0xD7, 0x44, 0x91, 0xA7, 0x2D, 0x30, 0x04, 0x09, 0xE5, 0x27, 0x73,
				0x1C, 0xD4, 0x1F, 0x2E, 0x20, 0x26, 0x89, 0x06, 0x3F, 0x9E, 0xBC, 0x7A, 0x52, 0x90, 0x78, 0x58,
				0xAC, 0xC3, 0x4A, 0x61, 0xD2, 0x00, 0x32, 0x55, 0xA3, 0xF5, 0xD0, 0x0B, 0x63, 0x7D, 0x94, 0xA6,
				0xE6, 0x74, 0x3E, 0x02, 0xF0, 0xED, 0x39, 0x6C, 0x22, 0x4C, 0xD1, 0xC5, 0xE7, 0x35, 0x8A, 0xB7,
				0x72, 0x03, 0x1B, 0x6D, 0xCC, 0x93, 0x29, 0x0F, 0xA8, 0xBD, 0x5E, 0xE8, 0xE3, 0x6A, 0xDD, 0x50,
				0xCA, 0x24, 0x98, 0x95, 0x51, 0xF2, 0x07, 0x4F, 0xE0, 0x9F, 0xF6, 0x2C, 0x10, 0x5D, 0x77, 0x7C,
				0xAB, 0xB1, 0xD6, 0x7B, 0x12, 0xAE, 0x23, 0x8C, 0xE2, 0xA9, 0x59, 0xF3, 0x54, 0x99, 0x96, 0x08,
				0xB8, 0x64, 0xA5, 0xC0, 0x56, 0x92, 0x14, 0x2B, 0x19, 0x7F, 0x0D, 0x97, 0xFA, 0x80, 0x82, 0xFB,
				0xF8, 0xE1, 0x75, 0x36, 0xB6, 0x31, 0xA1, 0x71, 0xAD, 0x9A, 0xDC, 0x4B, 0x57, 0xA2, 0xF1, 0x3A,
				0x34, 0x46, 0x01, 0xBE, 0xD8, 0x11, 0x2A, 0xB2, 0x05, 0x45, 0xE9, 0x84, 0xB9, 0x9D, 0xB3, 0x47,
				0xB0, 0x8E, 0x53, 0xEA, 0x4E, 0x69, 0x5C, 0xF7, 0x62, 0x25, 0x0A, 0x7E, 0x3B, 0x40, 0xBF, 0x5A,
				0x9C, 0x2F, 0xFE, 0x18, 0xAF, 0x79, 0xC4, 0xCD, 0x8D, 0x8F, 0xC2, 0x5F, 0xC7, 0xB4, 0x70, 0xC1,
				0xBA, 0x81, 0xFF, 0xE4, 0x87, 0x4D, 0x48, 0xCB, 0x1E, 0x1D, 0x3D, 0x67, 0x86, 0x0E, 0x5B, 0xCE
			};

			/*
				https://en.wikipedia.org/wiki/Lai%E2%80%93Massey_scheme

				The Lai–Massey scheme is a cryptographic structure used in the design of block ciphers.
				It is used in IDEA and IDEA NXT.
				The scheme was originally introduced by Xuejia Lai with the assistance of James L. Massey, hence the scheme's name, Lai-Massey.

				The Lai-Massey Scheme is similar to a Feistel Network in design, using a round function and a half-round function.
				The round function is a function which takes two inputs, a sub-key and a Data block, and which returns one output of equal length to the Data block.
				The half-round function takes two inputs and transforms them into two outputs.
				For any given round, the input is split into two halves, left and right.
				Initially, the inputs are passed through the half-round function.
				In each round, the difference between the inputs is passed to the round function along with a sub-key, and the result from the round function is then added to each input.
				The input is then passed to the half-round function, which is repeated a fixed number of times, and the final output is the encrypted data.
				Due to its design, it has an advantage over a Substitution-permutation network since the round-function does not need to be inverted
				just the half-round - enabling it to be more easily inverted, and enabling the round-function to be arbitrarily complex.
				The encryption and decryption processes are fairly similar, decryption instead requiring a reversal of the key schedule, an inverted half-round function, and that the round function's output be "subtracted" instead of "added".

				Lai-Massey方案是一种用于设计分块密码的密码器结构
				它被用于IDEA和IDEA NXT。

				该方案最初是由Xuejia Lai在James L. Massey的协助下提出的，因此该方案的名称为Lai-Massey

				Lai-Massey方案在设计上类似于Feistel网络，使用一个轮函数和一个半轮函数
				轮函数是一个需要两个输入的函数，一个子密钥和一个数据块，并返回一个与数据块等长的输出
				半轮函数接受两个输入，并将其转化为两个输出。对于任何给定的回合，输入被分成两半，即左和右
				最初，输入被传递给半轮函数。
				在每一轮中，输入之间的差异与一个子密钥一起被传递给轮函数，然后轮函数的结果被增加到每个输入
				然后，输入被传递到半轮函数中，重复固定的次数，最后的输出是加密的数据。
				由于它的设计，它比置换-排列网络更有优势，因为轮函数不需要被反转-只需要半轮函数被反转--使它更容易被反转，并使轮函数可以任意地复杂
				加密和解密过程相当相似，解密则需要颠倒密钥计划，倒置半轮函数，以及轮函数的输出被"减去"而不是"增加"

			*/
			inline std::uint64_t LaiMasseyFramework
			(
				std::uint64_t WordData,
				std::uint64_t WordKeyMaterial,
				TwilightDreamOfMagical::CustomSecurity::CryptionMode2MCAC4_FDW ThisExecuteMode
			);

			void ByteSubstitution
			(
				std::span<std::uint8_t> EachRoundDatas,
				TwilightDreamOfMagical::CustomSecurity::CryptionMode2MCAC4_FDW ThisExecuteMode
			);

			//每一轮过程的函数
			//The function of each round process
			void RoundFunction
			(
				std::span<std::uint64_t> EachRoundDatas,
				TwilightDreamOfMagical::CustomSecurity::CryptionMode2MCAC4_FDW ThisExecuteMode
			);
		};
	}
}

#endif	//ALGORITHM_OALDRESPUZZLECRYPTIC_OALDRESPUZZLE_CRYPTIC_HPP
