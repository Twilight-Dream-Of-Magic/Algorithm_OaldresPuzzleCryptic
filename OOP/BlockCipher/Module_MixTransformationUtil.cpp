#include "Module_MixTransformationUtil.hpp"

namespace TwilightDreamOfMagical::CustomSecurity
{
	//SymmetricEncryptionDecryption
	namespace SED::BlockCipher
	{
		namespace ImplementationDetails
		{
			/*
				该算法参考了中国商用流密码，祖冲之的混合变换轮函数
				The algorithm is referenced from the Chinese commercial stream cipher, Zu Chongzhi's mix transform round function

				非线性变换和线性变换函数
				Nonlinear transformations and linear transformation functions
			*/
			std::uint32_t Module_MixTransformationUtil::Word32Bit_KeyWithStreamCipherFunction( std::span<const std::uint32_t> RandomWordDataMaterial )
			{
				using TwilightDreamOfMagical::BaseOperation::rotate_left;
				using TwilightDreamOfMagical::BaseOperation::rotate_right;

				my_cpp2020_assert( RandomWordDataMaterial.size() == 4, "", std::source_location::current() );

				auto& StateValue0 = this->Word32Bit_StreamCipherStateRegisters[ 0 ];
				auto& StateValue1 = this->Word32Bit_StreamCipherStateRegisters[ 1 ];

				std::uint32_t RandomWordData0 = ( RandomWordDataMaterial[ 0 ] ^ StateValue0 ) + StateValue1;

				const std::uint32_t RandomWordData1 = StateValue0 + RandomWordDataMaterial[ 1 ];
				const std::uint32_t RandomWordData2 = StateValue1 ^ RandomWordDataMaterial[ 2 ];

				volatile std::uint32_t RandomWordDataA = ( RandomWordData1 << 16 ) | ( RandomWordData2 >> 16 );
				volatile std::uint32_t RandomWordDataB = ( RandomWordData2 << 16 ) | ( RandomWordData1 >> 16 );

				/*
					线性变换
					基于固定的二进制多项式, 伽罗瓦有限域(power(2, 32))

					Linear Transformation
					Based on a fixed binary polynomial, Galois finite field (power(2, 32))

					而且它是一个(MDS)最大距离可分离的矩阵！！！
					And it is a (MDS) maximum distance separable matrix!!!
					Chinese Paper Refernece: http://www.infocomm-journal.com/cjnis/CN/10.11959/j.issn.2096-109x.2016.00063
					Download: http://www.infocomm-journal.com/cjnis/CN/article/downloadArticleFile.do?attachType=PDF&id=169996
				*/
				StateValue0 = RandomWordDataA ^ rotate_left( RandomWordDataA, 2 ) ^ rotate_left( RandomWordDataA, 10 ) ^ rotate_left( RandomWordDataA, 18 ) ^ rotate_left( RandomWordDataA, 24 );

				StateValue1 = RandomWordDataB ^ rotate_left( RandomWordDataB, 8 ) ^ rotate_left( RandomWordDataB, 14 ) ^ rotate_left( RandomWordDataB, 22 ) ^ rotate_left( RandomWordDataB, 30 );

				/*
					非线性变换
					基于动态生成的字节替代盒的查找和替换

					Nonlinear Transformation
					Find and replace based on dynamically generated byte substitution boxes
				*/
				StateValue0 = ( ( MaterialSubstitutionBox0[ ( StateValue0 >> 24 ) & 0xFF ] ) << 24 ) | ( ( MaterialSubstitutionBox1[ ( StateValue0 >> 16 ) & 0xFF ] ) << 16 ) | ( ( MaterialSubstitutionBox0[ ( StateValue0 >> 8 ) & 0xFF ] ) << 8 ) | ( MaterialSubstitutionBox1[ StateValue0 & 0xFF ] );

				StateValue1 = ( ( MaterialSubstitutionBox0[ ( StateValue1 >> 24 ) & 0xFF ] ) << 24 ) | ( ( MaterialSubstitutionBox1[ ( StateValue1 >> 16 ) & 0xFF ] ) << 16 ) | ( ( MaterialSubstitutionBox0[ ( StateValue1 >> 8 ) & 0xFF ] ) << 8 ) | ( MaterialSubstitutionBox1[ StateValue1 & 0xFF ] );

				return RandomWordData0;
			}

			void Module_MixTransformationUtil::Word32Bit_Initialize()
			{
				auto& LFSR_Object = *( StateDataPointer->LFSR_ClassicPointer );
				auto& NLFSR_Object = *( StateDataPointer->NLFSR_ClassicPointer );
				auto& SDP_Object = *( StateDataPointer->SDP_ClassicPointer );

				auto& StateValue0 = this->Word32Bit_StreamCipherStateRegisters[ 0 ];
				auto& StateValue1 = this->Word32Bit_StreamCipherStateRegisters[ 1 ];

				std::uint64_t		   BaseNumber = NLFSR_Object() ^ SDP_Object( 0ULL, 0xFFFFFFFFFFFFFFFFULL );
				volatile std::uint64_t RandomNumber = 0;

				for ( size_t Count = 129; Count > 0; --Count )
				{
					BaseNumber = NLFSR_Object.unpredictable_bits( BaseNumber % 0xFFFFFFFFFFFFFFFFULL, 64 ) ^ LFSR_Object();
				}

				RandomNumber = NLFSR_Object() ^ ~( LFSR_Object() ^ BaseNumber );

				StateValue0 = static_cast<std::uint32_t>( RandomNumber >> 32 );
				StateValue1 = static_cast<std::uint32_t>( ( RandomNumber << 32 ) >> 32 );

				RandomNumber = 0;
			}

			std::vector<std::uint32_t> Module_MixTransformationUtil::Word32Bit_ExpandKey( std::span<const std::uint32_t> NeedHashDataWords )
			{
				using CommonToolkit::IntegerExchangeBytes::ByteSwap::byteswap;

				std::vector<std::uint32_t> ProcessedWordKeys( NeedHashDataWords.size() * 12, 0 );

				std::size_t NeedHashDataIndex = 0;
				while ( NeedHashDataIndex < NeedHashDataWords.size() )
				{

					/*
						Step 1 : Data word do bitwise reorganization
						数据字做比特重组
					*/

					std::uint32_t RestructedWordKey = this->WordBitRestruct( NeedHashDataWords[ NeedHashDataIndex ] );

					if constexpr ( std::endian::native == std::endian::big )
						RestructedWordKey = byteswap( RestructedWordKey );

					/*
						Step 2 : Data words do bitwise splitting
						数据字做比特分割
					*/

					std::uint32_t UpPartWord = ( RestructedWordKey >> 16 );
					std::uint32_t DownPartWord = ( RestructedWordKey << 16 ) >> 16;
					std::uint32_t LeftPartWord = ( RestructedWordKey & 0xF000'0000U ) | ( ( RestructedWordKey & 0x00F0'0000U ) << 4 ) | ( ( RestructedWordKey & 0x0000'F000U ) << 8 ) | ( ( RestructedWordKey & 0x0000'00F0U ) << 12 );
					std::uint32_t RightPartWord = ( ( RestructedWordKey & 0x0F00'0000U ) << 4 ) | ( ( RestructedWordKey & 0x000F'0000U ) << 8 ) | ( ( RestructedWordKey & 0x0000'0F00U ) << 12 ) | ( ( RestructedWordKey & 0x0000'000FU ) << 14 );

					/*
						Step 3 : Data words do byte mixing and number expansions
						数据字做字节混合和数量扩展
					*/

					volatile std::uint32_t DiffusionResult0 = UpPartWord ^ DownPartWord;
					volatile std::uint32_t DiffusionResult1 = LeftPartWord ^ RightPartWord;
					volatile std::uint32_t DiffusionResult2 = UpPartWord ^ LeftPartWord;
					volatile std::uint32_t DiffusionResult3 = DownPartWord ^ RightPartWord;
					volatile std::uint32_t DiffusionResult4 = UpPartWord ^ RightPartWord;
					volatile std::uint32_t DiffusionResult5 = DownPartWord ^ LeftPartWord;

					/*
						https://bigprimes.org/
						https://www.numberempire.com/primenumbers.php

						286331173
						3676758703
						4123665971
						3193679207
						339204479
						2017551733
						3451580309
						2711043323
						645676697
						1066195267
						4172536373
						3285900997
					*/

					std::uint32_t KeyIndex = 0;
					while ( KeyIndex < ProcessedWordKeys.size() )
					{
						ProcessedWordKeys[ KeyIndex ] ^= ( DiffusionResult0 << 8 | DiffusionResult4 ) + 0x11111125U;
						ProcessedWordKeys[ KeyIndex + 1 ] ^= ( DiffusionResult0 | DiffusionResult4 >> 24 ) - 0xDB26E2AFU;
						ProcessedWordKeys[ KeyIndex + 2 ] ^= ( DiffusionResult5 << 16 | DiffusionResult1 ) * 0xF5CA2633U;
						ProcessedWordKeys[ KeyIndex + 3 ] = ( DiffusionResult5 | DiffusionResult1 >> 16 ) % 0xBE5BAD67U;
						ProcessedWordKeys[ KeyIndex + 4 ] ^= ( DiffusionResult2 << 24 | DiffusionResult3 ) * 0x1437D97FU;
						ProcessedWordKeys[ KeyIndex + 5 ] ^= ( DiffusionResult2 | DiffusionResult3 >> 8 ) + 0x78416575U;
						ProcessedWordKeys[ KeyIndex + 6 ] = ( DiffusionResult0 >> 24 | DiffusionResult4 ) % 0xCDBAEF95U;
						ProcessedWordKeys[ KeyIndex + 7 ] ^= ( DiffusionResult0 | DiffusionResult4 << 8 ) - 0xA1973CFBU;
						ProcessedWordKeys[ KeyIndex + 8 ] ^= ( DiffusionResult5 >> 16 | DiffusionResult1 ) * 0x267C3E99U;
						ProcessedWordKeys[ KeyIndex + 9 ] ^= ( DiffusionResult5 | DiffusionResult1 << 16 ) - 0x3F8CD943U;
						ProcessedWordKeys[ KeyIndex + 10 ] = ( DiffusionResult2 >> 8 | DiffusionResult3 ) % 0xF8B3DA35U;
						ProcessedWordKeys[ KeyIndex + 11 ] ^= ( DiffusionResult2 | DiffusionResult3 << 24 ) + 0xC3DADEC5U;

						std::ranges::rotate( ProcessedWordKeys.begin(), ProcessedWordKeys.end() - 1, ProcessedWordKeys.end() );

						DiffusionResult0 -= ProcessedWordKeys[ KeyIndex ] | ProcessedWordKeys[ KeyIndex + 11 ];
						DiffusionResult5 += ProcessedWordKeys[ KeyIndex + 1 ] & ProcessedWordKeys[ KeyIndex + 10 ];
						DiffusionResult1 -= ProcessedWordKeys[ KeyIndex + 2 ] | ProcessedWordKeys[ KeyIndex + 9 ];
						DiffusionResult4 += ProcessedWordKeys[ KeyIndex + 3 ] & ProcessedWordKeys[ KeyIndex + 8 ];
						DiffusionResult2 -= ProcessedWordKeys[ KeyIndex + 4 ] | ProcessedWordKeys[ KeyIndex + 7 ];
						DiffusionResult3 += ProcessedWordKeys[ KeyIndex + 5 ] & ProcessedWordKeys[ KeyIndex + 6 ];

						std::ranges::rotate( ProcessedWordKeys.begin(), ProcessedWordKeys.end() - 1, ProcessedWordKeys.end() );

						DiffusionResult0 = this->WordBitRestruct( DiffusionResult0 );
						DiffusionResult1 = this->WordBitRestruct( DiffusionResult1 );
						DiffusionResult2 = this->WordBitRestruct( DiffusionResult2 );
						DiffusionResult3 = this->WordBitRestruct( DiffusionResult3 );
						DiffusionResult4 = this->WordBitRestruct( DiffusionResult4 );
						DiffusionResult5 = this->WordBitRestruct( DiffusionResult5 );

						KeyIndex += 12;
					}

					//临时数据置零，防止被分析
					//Temporary data zeroing to prevent analysis

					DiffusionResult0 = 0;
					DiffusionResult1 = 0;
					DiffusionResult2 = 0;
					DiffusionResult3 = 0;
					DiffusionResult4 = 0;
					DiffusionResult5 = 0;

					UpPartWord = 0;
					DownPartWord = 0;
					LeftPartWord = 0;
					RightPartWord = 0;

					++NeedHashDataIndex;
				}

				return ProcessedWordKeys;
			}

			std::uint32_t Module_MixTransformationUtil::WordBitRestruct( std::uint32_t WordKey )
			{
				WordKey = this->SwapBits( WordKey, 0, 9 );
				WordKey = this->SwapBits( WordKey, 1, 18 );
				WordKey = this->SwapBits( WordKey, 2, 27 );

				WordKey = this->SwapBits( WordKey, 5, 28 );
				WordKey = this->SwapBits( WordKey, 6, 21 );
				WordKey = this->SwapBits( WordKey, 7, 14 );

				WordKey = this->SwapBits( WordKey, 10, 24 );
				WordKey = this->SwapBits( WordKey, 11, 25 );
				WordKey = this->SwapBits( WordKey, 12, 30 );
				WordKey = this->SwapBits( WordKey, 13, 31 );

				WordKey = this->SwapBits( WordKey, 19, 4 );
				WordKey = this->SwapBits( WordKey, 20, 3 );

				WordKey = this->SwapBits( WordKey, 17, 2 );
				WordKey = this->SwapBits( WordKey, 22, 5 );

				WordKey = this->SwapBits( WordKey, 27, 15 );
				WordKey = this->SwapBits( WordKey, 28, 8 );

				return WordKey;
			}

			std::uint32_t Module_MixTransformationUtil::SwapBits( std::uint32_t Word, std::uint32_t BitPosition, std::uint32_t BitPosition2 )
			{
				/* Move BitPosition'th to rightmost side (Get Bit) */
				//std::uint32_t Bit1 = (Word >> BitPosition) & 1；

				/* Move BitPosition2'th to rightmost side (Get Bit) */
				//std::uint32_t Bit2 = (Word >> BitPosition2) & 1；

				/* Exclusive Or the two bits */
				//std::uint32_t BitMask = Bit1 ^ Bit2;

				/* Put the Exclusive or-ed bit back to their original positions */
				//BitMask = (BitMask << BitPosition) | (BitMask << BitPosition2);

				/* Exclusive or 'BitMask' with the original number so that the two sets are swapped */
				//return Word ^ BitMask;

				std::uint32_t BitMask = ( ( Word >> BitPosition ) & std::uint32_t { 1 } ) ^ ( ( Word >> BitPosition2 ) & std::uint32_t { 1 } );

				//If it is two same bits, then return the word that does not change
				if ( BitMask == std::uint32_t { 0 } )
					return Word;

				BitMask = ( BitMask << BitPosition ) | ( BitMask << BitPosition2 );
				return Word ^ BitMask;
			}

			std::array<std::uint8_t, 256> Module_MixTransformationUtil::RegenerationRandomMaterialSubstitutionBox( std::span<const std::uint8_t> OldDataBox )
			{
				volatile void* CheckPointer = nullptr;

				auto& NLFSR_Object = *( StateDataPointer->NLFSR_Pointer );

				const std::size_t			   OldDataArraySize = OldDataBox.size();
				SegmentTree<std::uint8_t, 256> SegmentTreeObject;

				std::array<std::uint8_t, 256> NewDataBox {};
				const std::size_t			  NewDataArraySize = NewDataBox.size();

				for ( std::size_t Index = 0, Index2 = 0; Index < OldDataArraySize && Index2 < NewDataArraySize; Index++, Index2++ )
				{
					if ( Index == OldDataArraySize - 1 && OldDataBox[ Index ] == SegmentTreeObject.Get( 0 ) )
					{
						//Need to re-operate data
						CheckPointer = memory_set_no_optimize_function<0x00>( NewDataBox.data(), NewDataBox.size() );
						CheckPointer = nullptr;
						SegmentTreeObject.Clear();
						Index = 0;
						Index2 = 0;
						continue;
					}

					std::size_t Order = NLFSR_Object() % ( OldDataArraySize - Index ), Position = SegmentTreeObject.Get( Order );
					while ( OldDataBox[ Index ] == Position )
						Order = NLFSR_Object() % ( OldDataArraySize - Index ), Position = SegmentTreeObject.Get( Order );
					NewDataBox[ Index2 ] = Position, SegmentTreeObject.Set( Position );
				}

				return NewDataBox;
			}
		}  // namespace ImplementationDetails
	}	   // namespace SED::BlockCipher
}  // namespace TwilightDreamOfMagical::CustomSecurity
